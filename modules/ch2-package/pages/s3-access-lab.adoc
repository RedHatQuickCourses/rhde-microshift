:time_estimate: 5

= Lab: Access MicroShift as a Developer or Platform Engineer

_Estimated reading time: *{time_estimate} minutes*._

Objective::

Configure remote access to MicroShift as privileged and unprivileged users.

WARNING: Work In Progress

== Before you Begin

You need a _test machine_ where you installed, configured, and verified MicroShift, by following the instructions from the xref:s2-install-lab.adoc[previous lab].

You also need a _development machine_ from which you will access the MicroShift instance on your _test machine_.

Finally, you also need a _mirror registry_ machine, already configured with a mirror registry for Red Hat OpenShift and pre-populared with container images required by MicroShift and course activities. Make sure that your _mirror registry machine_ machine was configured and verified by following the instructions from the xref:ch1-microshift:s3-prepare-lab.adoc[first lab] of this course.

These instructions were tested on RHEL 9.4 [tentative!] but should work with minimal or no change on newer and older RHEL 9.x releases.

If you are using the course classroom, you will log in on the `workstation` VM, which is your _development machine_, as the user `student` with password `student`, and you start SSH sessions from `workstation` VM to the `serverb` VM, which is your _test machine_, using the same user. If not, please adapt the instructions to your test environment.

You will perform initial steps of this lab on your _test machine_ and final steps on your _development machine_.

== Instructions

1. Log in on your _test machine_ and verify that MicroShift is up and running.

.. Check that the MicroShift service is active.
+
[source,subs="verbatim,quotes"]
--
$ *sudo systemctl is-active microshift*
active
--

.. Check that all pods are running and all their containers are ready and all their containers are running
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/local-admin get pod -A*
NAMESPACE              	NAME                                   	READY   STATUS	RESTARTS    	AGE
kube-system            	csi-snapshot-controller-69ddff88c8-hr9dt   1/1 	Running   0           	6m37s
kube-system            	csi-snapshot-webhook-74dc497864-hfdw7  	1/1 	Running   0           	6m41s
openshift-dns          	dns-default-9z4ph                      	2/2 	Running   0           	5m55s
openshift-dns          	node-resolver-prvjx                    	1/1 	Running   0           	6m39s
openshift-ingress      	router-default-575b4fc7-tg5lz          	1/1 	Running   0           	6m37s
openshift-ovn-kubernetes   ovnkube-master-wj4gv                   	4/4 	Running   1 (5m57s ago)   6m39s
openshift-ovn-kubernetes   ovnkube-node-fdpm8                     	1/1 	Running   1 (5m58s ago)   6m39s
openshift-service-ca   	service-ca-9db855698-zd7vg             	1/1 	Running   0           	6m36s
openshift-storage      	lvms-operator-7f544467bc-cqf2n         	1/1 	Running   0           	6m40s
openshift-storage      	vg-manager-tjrs2                       	1/1 	Running   0           	5m25s
--
+
NOTE: Remember that you copied the autogenerated kubeconfig file to `~/local-admin` in the xref:s2-install-lab.adoc[previous lab]

2. First, configure access to a developer kind of user. Create a namespace and a service account with limited read-write access to that namespace.

.. Create a namespace named `user` and a service account also named `user` in that namespace, them grant to the service account rights to create application resources on the namespace.
+
[source,subs="verbatim,quotes"]
--
$ *export KUBECONFIG=~/local-admin*
$ *oc whoami*
system:admin
$ *oc create namespace user*
namespace/user created
$ *oc create sa user -n user*
serviceaccount/user created
$ *oc create rolebinding user --clusterrole edit --serviceaccount user:user -n user*
--

.. Use Kubernetes impersonation to verify that the service account has the intended rights and nothing more. First, check that the service account has access to the namespace but not to other namespaces, nor to non-namespaced resources.
+
[source,subs="verbatim,quotes"]
--
$ *oc --as system:serviceaccount:user:user get sa -n user*
NAME      SECRETS   AGE
default   0         8m48s
user      0         6m58s
$ *oc --as system:serviceaccount:user:user get sa -n default*
Error from server (Forbidden): serviceaccounts is forbidden: User "system:serviceaccount:user:user" cannot list resource "serviceaccounts" in API group "" in the namespace "default"
$ *oc --as system:serviceaccount:user:user get node*
Error from server (Forbidden): nodes is forbidden: User "system:serviceaccount:user:user" cannot list resource "nodes" in API group "" at the cluster scope
--

.. Then check that the service account can manage common application resources but not policy resources.
+
[source,subs="verbatim,quotes"]
--
$ *oc --as system:serviceaccount:user:user create configmap test1 --from-literal one=1 -n user*
NAME      SECRETS   AGE
default   0         8m48s
user      0         6m58s
$ *oc --as system:serviceaccount:user:user get configmap -n user*
NAME                       DATA   AGE
kube-root-ca.crt           1      15m
openshift-service-ca.crt   1      15m
test1                      1      11s
$ *oc --as system:serviceaccount:user:user create quota test --hard pods=2 -n user*
error: failed to create quota: resourcequotas is forbidden: User "system:serviceaccount:user:user" cannot create resource "resourcequotas" in API group "" in the namespace "user"
--
+
NOTE: If you wish to grant rights to manage resources such as quotas and network policies, for a namespace administrator, platform engineer, or site reliability engineer role, you must grant the `admin` cluster role instead of the `edit` cluster role.


3. Create another namespace and grant limited read-only access to the service account. Remember that managing namespaces requires cluster administration rights in Kubernetes and MicroShift does NOT include self-service capabilities from OpenShift.

.. Create a second namespace and grant only the `view` role to the service account.
+
[source,subs="verbatim,quotes"]
--
$ *oc create namespace project*
namespace/project created
$ *oc create rolebinding user --clusterrole view --serviceaccount user:user -n project*
--

.. Verify that the service account can view but not manage application resources from the second namespace.
+
[source,subs="verbatim,quotes"]
--
$ *oc create configmap test2 --from-literal two=2 -n project*
configmap/test2 created
$ *oc --as system:serviceaccount:user:user get configmap -n project*
NAME                       DATA   AGE
kube-root-ca.crt           1      89s
openshift-service-ca.crt   1      89s
test2                      1      35s
$ *oc --as system:serviceaccount:user:user create configmap test3 --from-literal three=3 -n project*
error: failed to create configmap: configmaps is forbidden: User "system:serviceaccount:user:user" cannot create resource "configmaps" in API group "" in the namespace "project"
--

4. Create a kubeconfig file with a token from the service account.

.. Create a secret for the service account.
+
Recent Kubernetes and OpenShift releases do NOT automatically create secret tokens for service accounts anymore, and the `oc create` command does not support creating that kind of token. You must create the secret from a YAML file.
+
You can download a https://raw.githubusercontent.com/RedHatQuickCourses/rhde-build-samples/refs/heads/main/microshift/user-token.yaml[template] for such secret from the course samples repository in GitHub.
+
[source,subs="verbatim,quotes"]
--
$ *cat <<EOF >user-token.yaml*
apiVersion: v1
kind: Secret
metadata:
  name: user-token
  annotations:
    kubernetes.io/service-account.name: "user"
type: kubernetes.io/service-account-token
EOF
$ *oc apply -f user-token.yaml -n user*
secret/user-token created
--

.. Extract the token from the secret to a temporary file.
+
[source,subs="verbatim,quotes"]
--
$ *mkdir temp-token*
$ *--keys token --to . -n user*
token
--

.. Copy the autogenerated kubeconfig file for remote access to MicroShift. You will use it as a basis for the kubeconfig for your unprivileged service account.
+
[source,subs="verbatim,quotes"]
--
$ *unset KUBECONFIG*
$ *sudo cp /var/lib/microshift/resources/kubeadmin/serverb/kubeconfig ~/remote-admin*
$ *sudo chown student:student ~/remote-admin*
$ *chmod a-w ~/remote-admin*
$ *oc --kubeconfig ~/remote-admin whoami*
system:admin
$ *oc --kubeconfig ~/remote-admin get node*
NAME      STATUS   ROLES                         AGE   VERSION
serverb   Ready    control-plane,master,worker   23h   v1.30.5
--

.. Create a copy of the kubeconfig file for remote access and change its user credentials and namespace.
+
[source,subs="verbatim,quotes"]
--
$ *cp remote-admin remote-user*
$ *oc --kubeconfig ~/remote-user config delete-user user*
deleted user user from /home/student/remote-user
$ *oc --kubeconfig ~/remote-user config set-credentials user --token $(cat token)*
User "user" set.
$ *oc --kubeconfig ~/remote-user config set-context microshift --namespace user --user user --cluster microshift*
Context "microshift" modified.
--

.. Check that the new kubeconfig authenticates as the service account and has access to the first namespace created during this lab.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-user whoami*
system:serviceaccount:user:user
$ *oc --kubeconfig ~/remote-user get configmap*
NAME                       DATA   AGE
kube-root-ca.crt           1      107m
openshift-service-ca.crt   1      107m
test1                      1      92m
--

5. Now suppose you need to configure access to a cluster administrator user. Instead of sharing the autogenerated kubeconfig, create a kubeconfig like you could for a developer user and grant the unprivileged user rights to impersonate a user with cluster administration rights.
+

.. Create a cluster role binding that grants the `cluster-admin` role to a non-existent user.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/local-admin create clusterrolebinding cluster-admin-user --clusterrole cluster-admin --user admin*
clusterrolebinding.rbac.authorization.k8s.io/cluster-admin-user created
--

.. Create a cluster role that grants the `impersonate` verb for the non-existent user.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/local-admin create clusterrole sudo-admin --resource users --resource-name admin --verb impersonate*
clusterrole.rbac.authorization.k8s.io/sudo-admin created
--

.. Create a cluster role binding that grants the service account access to the new cluster role.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/local-admin create clusterrolebinding sudo-user --clusterrole sudo-admin --serviceaccount user:user*
clusterrolebinding.rbac.authorization.k8s.io/sudo-user created
--

.. Check that the service account can impersonate the non-existent user to manage resources that would require cluster administration rights.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-user whoami*
system:serviceaccount:user:user
$ *oc --kubeconfig ~/remote-user get nodes*
Error from server (Forbidden): nodes is forbidden: User "system:serviceaccount:user:user" cannot list resource "nodes" in API group "" at the cluster scope
$ *oc --kubeconfig ~/remote-user --as admin whoami*
admin
$ *oc --kubeconfig ~/remote-user --as admin get nodes*
NAME      STATUS   ROLES                         AGE   VERSION
serverb   Ready    control-plane,master,worker   25h   v1.30.5
--

6. Now that you have your kubeconfig files ready and tested, prepare your _test machine_ to accept remote requests to the Kubernetes API server of MicroShift.

.. First, notice that the kubeconfigs are configured with different API URLs.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-admin whoami --show-server*
https://serverb.lab.redhat.com:6443
$ *oc --kubeconfig ~/local-admin whoami --show-server*
https://localhost:6443
--


.. Allow remote access to MicroShift on the system firewall.
+
[source,subs="verbatim,quotes"]
--
$ *sudo firewall-cmd --permanent --zone=public --add-port=6443/tcp*
success
$ *sudo firewall-cmd --reload*
success
--

7. Switch to your _development machine_ to test remote access to the MicroShift instance.

.. Copy the kubeconfig files for cluster administrator and service account.
+
[source,subs="verbatim,quotes"]
--
$ *scp serverb:~/remote-admin .*
$ *chmod a-w ~/remote-admin*
$ *scp serverb:~/remote-user .*
--
NOTE: It is recommended that you save the kubeconfig file for `system:admin` in protected storage and use it only as a breaking class alternative, for emergencies. For day-to-day work, use a kubeconfig for a service account.

.. Check that you can access MicroShoft remotely using the kubeconfig for a cluster administrator.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-admin get node*
NAME      STATUS   ROLES                         AGE   VERSION
serverb   Ready    control-plane,master,worker   24h   v1.30.5
--

.. Check that you can access MicroShoft remotely using the kubeconfig for a service account.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-user get configmap*
NAME                       DATA   AGE
kube-root-ca.crt           1      115m
openshift-service-ca.crt   1      115m
test                       1      100m
$ *oc --kubeconfig ~/remote-user get configmap -n project*
NAME                       DATA   AGE
kube-root-ca.crt           1      99m
openshift-service-ca.crt   1      99m
test2                      1      98m
--

.. Finally, check that Kubernetes impersonation also works for remote access.
+
[source,subs="verbatim,quotes"]
--
$ *oc --kubeconfig ~/remote-user --as admin get node*
NAME      STATUS   ROLES                         AGE   VERSION
serverb   Ready    control-plane,master,worker   25h   v1.30.5
--

You now have a kubeconfig file for an unprivileged service account which you can use to deploy applications to pre-provisioned namespaces on MicroShift, and have also granted impersonation rights to the service account so it can perform Kubernetes cluster administration tasks on a MicroShift instance.

== Next Steps

The next activity uses the kubeconfig file created here to deploy a simple application on MicroShift.

